# Using createEffect


The old effect from the workshop:

```js
export class AuthEffects {
  @Effect()
  login$ = this.actions$.pipe(
    ofType(AuthActionTypes.Login),
    mergeMap((action: authActions.Login) =>
      this.authService
        .login(action.payload)
        .pipe(
          map((user: User) => new authActions.LoginSuccess(user)),
          catchError(error => of(new authActions.LoginFail(error)))
        )
    )
  );
  ...
```

The automatically generated by Nrwl 9:

```js
export class AuthEffects {
  loadAuth$ = createEffect(() =>
    this.actions$.pipe(
      ofType(AuthActions.loadAuth),
      fetch({
        run: action => {
          // Your custom service 'load' logic goes here. For now just return a success action...
          return AuthActions.loadAuthSuccess({ auth: [] });
        },

        onError: (action, error) => {
          console.error('Error', error);
          return AuthActions.loadAuthFailure({ error });
        }
      })
    )
  );
  ...
```

So yeah, pretty different.  Having trouble making an updated version.

There is no effect in the counter example from the stratum app.

The docs say *Effects decrease the responsibility of the component.*  I suppose the counter example has too little responsibility.  The official example [here] shows more like the old version:

```js
export class MovieEffects {
  loadMovies$ = createEffect(() => this.actions$.pipe(
    ofType('[Movies Page] Load Movies'),
    mergeMap(() => this.moviesService.getAll()
      .pipe(
        map(movies => ({ type: '[Movies API] Movies Loaded Success', payload: movies })),
        catchError(() => EMPTY)
      ))
    )
  );

  constructor(
    private actions$: Actions,
    private moviesService: MoviesService
  ) {}
}
```

The reducer code is fleshed out [in the next part, titled "13 - NgRx Effects"](https://duncanhunter.gitbook.io/enterprise-angular-applications-with-ngrx-and-nx/13-ngrx-effects).

The reducer shown here has four parts:

```js
interface AuthData { }
export interface AuthState { }
export const initialState: AuthData = { }
export function authReducer( )
```

Using the action the old way looks like this in the login.component.ts:

```js
this.store.dispatch(new authActions.Login(authenticate));
```

The new way of doing things looks like this:

```js
this.store.dispatch(login({ payload: authenticate }));
```

Then we have a problem of how to do things in the effect:

```js
.login(action.payload)
              ^^^^^^^
Property 'payload' does not exist on type 'AuthActionTypes.Login'.ts(2339)
```

Updating the first effect, this is looking good in that there are no TS errors:

```js
@Effect() login$ = this.actions$.pipe(
  ofType(AuthActionTypes.Login),
  fetch({
    run: action => {
      this.authService
      .login(action)
    },
    onError: (action, error) => {
      console.error('Error', error);
      return AuthActions.loginFailure(error);
    }
  })
);
```

However, will the login action get the user object as happens in the map function of the old workshop code?

```js
map((user: User) => new authActions.LoginSuccess(user)),
```

Compared to the old way of doing this, ```mergeMap((action: authActions.Login)``` is replaced by the shorter ```run: action```.

The second one will need more work.  The workshop code shows:

```js
@Effect({ dispatch: false }) navigateToProfile$ = this.actions$.pipe(
    ofType(AuthActionTypes.LoginSuccess),
    map((action: authActions.LoginSuccess) => action.payload),
    tap(() => this.router.navigate([`/products`]))
  );
```
